"""
Vulnerability Management System.

Features:
- Automated vulnerability scanning (dependencies, containers, OS packages)
- CVE tracking and assessment (CVSS scoring)
- Patch management workflow
- Vulnerability prioritization
- Integration with incident response

NIS2 Compliance: Article 21.2(c) - Vulnerability Handling and Disclosure
"""

import asyncio
import hashlib
import json
import logging
import subprocess
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional
import re

try:
    import aiohttp
except ImportError:
    aiohttp = None


class VulnerabilitySeverity(Enum):
    """Vulnerability severity based on CVSS score."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    NONE = "none"          # CVSS 0.0


class VulnerabilityStatus(Enum):
    """Vulnerability status in patch management workflow."""
    DETECTED = "detected"           # Just discovered
    ASSESSED = "assessed"           # Severity and impact evaluated
    PATCHING_AVAILABLE = "patching_available"  # Patch exists
    PATCHING_SCHEDULED = "patching_scheduled"  # Patch deployment scheduled
    PATCHED = "patched"            # Patch applied
    MITIGATED = "mitigated"        # Workaround applied (no patch)
    ACCEPTED_RISK = "accepted_risk"  # Risk accepted (documented)
    FALSE_POSITIVE = "false_positive"  # Not actually vulnerable


@dataclass
class Vulnerability:
    """Vulnerability record."""
    vuln_id: str  # CVE-YYYY-NNNNN or internal ID
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None

    # Affected component
    component_type: str = "unknown"  # python_package, os_package, container, code
    component_name: str = "unknown"
    component_version: str = "unknown"

    # Discovery
    detected_at: str = field(default_factory=lambda: datetime.utcnow().isoformat() + 'Z')
    detected_by: str = "automated_scan"  # automated_scan, manual_audit, disclosure
    scanner: Optional[str] = None  # safety, pip-audit, trivy, etc.

    # Assessment
    status: VulnerabilityStatus = VulnerabilityStatus.DETECTED
    exploitability: Optional[str] = None  # high, medium, low, none
    affected_systems: List[str] = field(default_factory=list)

    # Remediation
    fix_available: bool = False
    fixed_version: Optional[str] = None
    patch_deployed_at: Optional[str] = None
    mitigation_notes: Optional[str] = None

    # References
    cve_url: Optional[str] = None
    references: List[str] = field(default_factory=list)

    # Tracking
    risk_accepted: bool = False
    risk_accepted_by: Optional[str] = None
    risk_acceptance_reason: Optional[str] = None
    retest_date: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'vuln_id': self.vuln_id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'component_type': self.component_type,
            'component_name': self.component_name,
            'component_version': self.component_version,
            'detected_at': self.detected_at,
            'detected_by': self.detected_by,
            'scanner': self.scanner,
            'status': self.status.value,
            'exploitability': self.exploitability,
            'affected_systems': self.affected_systems,
            'fix_available': self.fix_available,
            'fixed_version': self.fixed_version,
            'patch_deployed_at': self.patch_deployed_at,
            'mitigation_notes': self.mitigation_notes,
            'cve_url': self.cve_url,
            'references': self.references,
            'risk_accepted': self.risk_accepted,
            'risk_accepted_by': self.risk_accepted_by,
            'risk_acceptance_reason': self.risk_acceptance_reason,
            'retest_date': self.retest_date,
        }


class VulnerabilityScanner:
    """
    Automated vulnerability scanner.

    Scans for vulnerabilities in:
    - Python dependencies (pip packages)
    - OS packages (apt/yum)
    - Container images (Docker)
    - Application code (static analysis)
    """

    def __init__(self):
        """Initialize vulnerability scanner."""
        self.logger = logging.getLogger(__name__)

    async def scan_python_dependencies(self) -> List[Vulnerability]:
        """
        Scan Python dependencies for vulnerabilities.

        Uses pip-audit to check installed packages against known CVEs.

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        try:
            # Run pip-audit
            result = await asyncio.create_subprocess_exec(
                'pip-audit', '--format', 'json',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await result.communicate()

            if result.returncode == 0:
                # No vulnerabilities found
                self.logger.info("Python dependency scan: No vulnerabilities found")
                return vulnerabilities

            # Parse output
            if stdout:
                data = json.loads(stdout.decode())

                for package_data in data.get('dependencies', []):
                    package_name = package_data.get('name', 'unknown')
                    package_version = package_data.get('version', 'unknown')

                    for vuln_data in package_data.get('vulns', []):
                        vuln_id = vuln_data.get('id', 'UNKNOWN')

                        # Parse CVSS score
                        cvss_score = None
                        severity = VulnerabilitySeverity.MEDIUM

                        if 'fix_versions' in vuln_data:
                            fix_available = len(vuln_data['fix_versions']) > 0
                            fixed_version = vuln_data['fix_versions'][0] if fix_available else None
                        else:
                            fix_available = False
                            fixed_version = None

                        vulnerability = Vulnerability(
                            vuln_id=vuln_id,
                            title=f"Vulnerability in {package_name}",
                            description=vuln_data.get('description', 'No description available'),
                            severity=severity,
                            cvss_score=cvss_score,
                            component_type='python_package',
                            component_name=package_name,
                            component_version=package_version,
                            scanner='pip-audit',
                            fix_available=fix_available,
                            fixed_version=fixed_version,
                            cve_url=f"https://nvd.nist.gov/vuln/detail/{vuln_id}" if vuln_id.startswith('CVE-') else None,
                        )

                        vulnerabilities.append(vulnerability)

                self.logger.info(f"Python dependency scan: Found {len(vulnerabilities)} vulnerabilities")

        except FileNotFoundError:
            self.logger.warning("pip-audit not installed. Install with: pip install pip-audit")
        except Exception as e:
            self.logger.error(f"Python dependency scan failed: {e}")

        return vulnerabilities

    async def scan_with_safety(self) -> List[Vulnerability]:
        """
        Scan Python dependencies using safety.

        Alternative to pip-audit, uses safety database.

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        try:
            # Run safety check
            result = await asyncio.create_subprocess_exec(
                'safety', 'check', '--json',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await result.communicate()

            if stdout:
                data = json.loads(stdout.decode())

                for vuln_data in data:
                    package_name = vuln_data[0]
                    package_version = vuln_data[2]
                    vuln_id = vuln_data[3]
                    description = vuln_data[4]

                    vulnerability = Vulnerability(
                        vuln_id=vuln_id,
                        title=f"Vulnerability in {package_name}",
                        description=description,
                        severity=VulnerabilitySeverity.MEDIUM,  # safety doesn't provide CVSS
                        component_type='python_package',
                        component_name=package_name,
                        component_version=package_version,
                        scanner='safety',
                        fix_available=True,  # safety only reports if fix exists
                        cve_url=f"https://nvd.nist.gov/vuln/detail/{vuln_id}" if vuln_id.startswith('CVE-') else None,
                    )

                    vulnerabilities.append(vulnerability)

                self.logger.info(f"Safety scan: Found {len(vulnerabilities)} vulnerabilities")

        except FileNotFoundError:
            self.logger.warning("safety not installed. Install with: pip install safety")
        except Exception as e:
            self.logger.error(f"Safety scan failed: {e}")

        return vulnerabilities

    async def scan_os_packages(self) -> List[Vulnerability]:
        """
        Scan OS packages for vulnerabilities.

        Checks for outdated system packages with known vulnerabilities.

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        try:
            # Check for apt (Debian/Ubuntu)
            result = await asyncio.create_subprocess_exec(
                'which', 'apt',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()

            if result.returncode == 0:
                # apt is available
                check_result = await asyncio.create_subprocess_exec(
                    'apt', 'list', '--upgradable',
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )

                stdout, _ = await check_result.communicate()

                if stdout:
                    lines = stdout.decode().split('\n')
                    for line in lines[1:]:  # Skip header
                        if line.strip():
                            # Parse: package/version [arch] current_ver upgradable_to new_ver
                            match = re.match(r'(\S+)/\S+\s+(\S+)\s+\S+\s+\[upgradable from: (\S+)\]', line)
                            if match:
                                package_name = match.group(1)
                                new_version = match.group(2)
                                current_version = match.group(3)

                                vulnerability = Vulnerability(
                                    vuln_id=f"OS-PACKAGE-{package_name}",
                                    title=f"Outdated OS package: {package_name}",
                                    description=f"Package {package_name} has available security update",
                                    severity=VulnerabilitySeverity.MEDIUM,
                                    component_type='os_package',
                                    component_name=package_name,
                                    component_version=current_version,
                                    scanner='apt',
                                    fix_available=True,
                                    fixed_version=new_version,
                                )

                                vulnerabilities.append(vulnerability)

                self.logger.info(f"OS package scan: Found {len(vulnerabilities)} outdated packages")

        except Exception as e:
            self.logger.error(f"OS package scan failed: {e}")

        return vulnerabilities

    async def scan_containers(self, image_names: List[str]) -> List[Vulnerability]:
        """
        Scan container images for vulnerabilities using trivy.

        Args:
            image_names: List of Docker image names to scan

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        try:
            for image_name in image_names:
                result = await asyncio.create_subprocess_exec(
                    'trivy', 'image', '--format', 'json', '--quiet', image_name,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )

                stdout, stderr = await result.communicate()

                if stdout:
                    data = json.loads(stdout.decode())

                    for result_data in data.get('Results', []):
                        for vuln_data in result_data.get('Vulnerabilities', []):
                            vuln_id = vuln_data.get('VulnerabilityID', 'UNKNOWN')
                            package_name = vuln_data.get('PkgName', 'unknown')
                            installed_version = vuln_data.get('InstalledVersion', 'unknown')
                            fixed_version = vuln_data.get('FixedVersion')
                            severity_str = vuln_data.get('Severity', 'MEDIUM')

                            # Map trivy severity to our enum
                            severity_map = {
                                'CRITICAL': VulnerabilitySeverity.CRITICAL,
                                'HIGH': VulnerabilitySeverity.HIGH,
                                'MEDIUM': VulnerabilitySeverity.MEDIUM,
                                'LOW': VulnerabilitySeverity.LOW,
                            }
                            severity = severity_map.get(severity_str, VulnerabilitySeverity.MEDIUM)

                            vulnerability = Vulnerability(
                                vuln_id=vuln_id,
                                title=vuln_data.get('Title', f"Vulnerability in {package_name}"),
                                description=vuln_data.get('Description', 'No description available'),
                                severity=severity,
                                cvss_score=vuln_data.get('CVSS', {}).get('nvd', {}).get('V3Score'),
                                component_type='container',
                                component_name=package_name,
                                component_version=installed_version,
                                scanner='trivy',
                                fix_available=bool(fixed_version),
                                fixed_version=fixed_version,
                                cve_url=f"https://nvd.nist.gov/vuln/detail/{vuln_id}" if vuln_id.startswith('CVE-') else None,
                                references=vuln_data.get('References', []),
                                affected_systems=[image_name],
                            )

                            vulnerabilities.append(vulnerability)

                self.logger.info(f"Container scan ({image_name}): Found {len(vulnerabilities)} vulnerabilities")

        except FileNotFoundError:
            self.logger.warning("trivy not installed. Install from: https://github.com/aquasecurity/trivy")
        except Exception as e:
            self.logger.error(f"Container scan failed: {e}")

        return vulnerabilities

    def calculate_severity_from_cvss(self, cvss_score: float) -> VulnerabilitySeverity:
        """
        Calculate severity from CVSS score.

        Args:
            cvss_score: CVSS score (0.0-10.0)

        Returns:
            Vulnerability severity
        """
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif cvss_score > 0.0:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.NONE


class VulnerabilityManager:
    """
    Manages vulnerabilities throughout their lifecycle.

    Handles vulnerability tracking, assessment, prioritization, and remediation.
    """

    def __init__(self, vuln_dir: Path = Path('vulnerabilities')):
        """
        Initialize vulnerability manager.

        Args:
            vuln_dir: Directory to store vulnerability records
        """
        self.vuln_dir = vuln_dir
        self.vuln_dir.mkdir(parents=True, exist_ok=True)

        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.logger = logging.getLogger(__name__)

        # Load existing vulnerabilities
        self._load_vulnerabilities()

    def add_vulnerability(self, vulnerability: Vulnerability) -> bool:
        """
        Add new vulnerability or update existing one.

        Args:
            vulnerability: Vulnerability to add

        Returns:
            True if new vulnerability, False if updated existing
        """
        is_new = vulnerability.vuln_id not in self.vulnerabilities

        # Check if vulnerability already exists
        if not is_new:
            existing = self.vulnerabilities[vulnerability.vuln_id]

            # Update status if still detected
            if existing.status in (VulnerabilityStatus.PATCHED, VulnerabilityStatus.MITIGATED):
                # Was previously fixed, now detected again (regression)
                self.logger.warning(f"Vulnerability {vulnerability.vuln_id} detected again after being marked as {existing.status.value}")
                vulnerability.status = VulnerabilityStatus.DETECTED
            else:
                # Keep existing status
                vulnerability.status = existing.status

        self.vulnerabilities[vulnerability.vuln_id] = vulnerability
        self._save_vulnerability(vulnerability)

        if is_new:
            self.logger.info(f"New vulnerability detected: {vulnerability.vuln_id} ({vulnerability.severity.value})")
        else:
            self.logger.info(f"Updated vulnerability: {vulnerability.vuln_id}")

        return is_new

    def update_vulnerability(
        self,
        vuln_id: str,
        status: Optional[VulnerabilityStatus] = None,
        patch_deployed_at: Optional[str] = None,
        mitigation_notes: Optional[str] = None,
        risk_accepted: Optional[bool] = None,
        risk_accepted_by: Optional[str] = None,
        risk_acceptance_reason: Optional[str] = None
    ):
        """
        Update vulnerability status.

        Args:
            vuln_id: Vulnerability ID
            status: New status
            patch_deployed_at: Patch deployment timestamp
            mitigation_notes: Mitigation notes
            risk_accepted: Risk acceptance flag
            risk_accepted_by: User who accepted risk
            risk_acceptance_reason: Reason for risk acceptance
        """
        vuln = self.vulnerabilities.get(vuln_id)
        if not vuln:
            self.logger.warning(f"Vulnerability not found: {vuln_id}")
            return

        if status:
            vuln.status = status

        if patch_deployed_at:
            vuln.patch_deployed_at = patch_deployed_at

        if mitigation_notes:
            vuln.mitigation_notes = mitigation_notes

        if risk_accepted is not None:
            vuln.risk_accepted = risk_accepted
            vuln.risk_accepted_by = risk_accepted_by
            vuln.risk_acceptance_reason = risk_acceptance_reason

        self._save_vulnerability(vuln)
        self.logger.info(f"Updated vulnerability {vuln_id}: {status.value if status else 'no status change'}")

    def get_vulnerability(self, vuln_id: str) -> Optional[Vulnerability]:
        """
        Get vulnerability by ID.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            Vulnerability or None
        """
        return self.vulnerabilities.get(vuln_id)

    def list_vulnerabilities(
        self,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        component_type: Optional[str] = None
    ) -> List[Vulnerability]:
        """
        List vulnerabilities with optional filtering.

        Args:
            severity: Filter by severity
            status: Filter by status
            component_type: Filter by component type

        Returns:
            List of vulnerabilities
        """
        result = list(self.vulnerabilities.values())

        if severity:
            result = [v for v in result if v.severity == severity]

        if status:
            result = [v for v in result if v.status == status]

        if component_type:
            result = [v for v in result if v.component_type == component_type]

        return result

    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """
        Get vulnerability summary statistics.

        Returns:
            Summary statistics
        """
        total = len(self.vulnerabilities)

        by_severity = {
            'critical': len([v for v in self.vulnerabilities.values() if v.severity == VulnerabilitySeverity.CRITICAL]),
            'high': len([v for v in self.vulnerabilities.values() if v.severity == VulnerabilitySeverity.HIGH]),
            'medium': len([v for v in self.vulnerabilities.values() if v.severity == VulnerabilitySeverity.MEDIUM]),
            'low': len([v for v in self.vulnerabilities.values() if v.severity == VulnerabilitySeverity.LOW]),
        }

        by_status = {
            'detected': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.DETECTED]),
            'assessed': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.ASSESSED]),
            'patching_available': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.PATCHING_AVAILABLE]),
            'patching_scheduled': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.PATCHING_SCHEDULED]),
            'patched': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.PATCHED]),
            'mitigated': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.MITIGATED]),
            'accepted_risk': len([v for v in self.vulnerabilities.values() if v.status == VulnerabilityStatus.ACCEPTED_RISK]),
        }

        fixable = len([v for v in self.vulnerabilities.values() if v.fix_available])

        return {
            'total': total,
            'by_severity': by_severity,
            'by_status': by_status,
            'fixable': fixable,
            'fix_rate': round(fixable / total * 100, 1) if total > 0 else 0,
        }

    def prioritize_vulnerabilities(self) -> List[Vulnerability]:
        """
        Prioritize vulnerabilities for remediation.

        Priority based on:
        1. Severity (CRITICAL > HIGH > MEDIUM > LOW)
        2. Exploitability (high > medium > low)
        3. Fix availability (fix available > no fix)

        Returns:
            Sorted list of vulnerabilities (highest priority first)
        """
        def priority_score(vuln: Vulnerability) -> tuple:
            # Severity score
            severity_scores = {
                VulnerabilitySeverity.CRITICAL: 4,
                VulnerabilitySeverity.HIGH: 3,
                VulnerabilitySeverity.MEDIUM: 2,
                VulnerabilitySeverity.LOW: 1,
                VulnerabilitySeverity.NONE: 0,
            }

            # Exploitability score
            exploit_scores = {'high': 3, 'medium': 2, 'low': 1, None: 0}

            # Fix availability (prefer vulnerabilities with available fixes)
            fix_score = 1 if vuln.fix_available else 0

            return (
                -severity_scores[vuln.severity],  # Negative for descending sort
                -exploit_scores.get(vuln.exploitability, 0),
                -fix_score,
            )

        # Filter only non-fixed vulnerabilities
        active_vulns = [
            v for v in self.vulnerabilities.values()
            if v.status not in (VulnerabilityStatus.PATCHED, VulnerabilityStatus.MITIGATED, VulnerabilityStatus.FALSE_POSITIVE)
        ]

        return sorted(active_vulns, key=priority_score)

    def _save_vulnerability(self, vulnerability: Vulnerability):
        """Save vulnerability to disk."""
        vuln_file = self.vuln_dir / f"{vulnerability.vuln_id}.json"
        # Replace invalid filename characters
        vuln_file = self.vuln_dir / f"{vulnerability.vuln_id.replace('/', '_').replace(':', '_')}.json"

        with open(vuln_file, 'w') as f:
            json.dump(vulnerability.to_dict(), f, indent=2, default=str)

    def _load_vulnerabilities(self):
        """Load existing vulnerabilities from disk."""
        for vuln_file in self.vuln_dir.glob('*.json'):
            try:
                with open(vuln_file, 'r') as f:
                    data = json.load(f)

                # Reconstruct vulnerability
                vuln = Vulnerability(
                    vuln_id=data['vuln_id'],
                    title=data['title'],
                    description=data['description'],
                    severity=VulnerabilitySeverity(data['severity']),
                    cvss_score=data.get('cvss_score'),
                    cvss_vector=data.get('cvss_vector'),
                    component_type=data.get('component_type', 'unknown'),
                    component_name=data.get('component_name', 'unknown'),
                    component_version=data.get('component_version', 'unknown'),
                    detected_at=data['detected_at'],
                    detected_by=data.get('detected_by', 'automated_scan'),
                    scanner=data.get('scanner'),
                    status=VulnerabilityStatus(data['status']),
                    exploitability=data.get('exploitability'),
                    affected_systems=data.get('affected_systems', []),
                    fix_available=data.get('fix_available', False),
                    fixed_version=data.get('fixed_version'),
                    patch_deployed_at=data.get('patch_deployed_at'),
                    mitigation_notes=data.get('mitigation_notes'),
                    cve_url=data.get('cve_url'),
                    references=data.get('references', []),
                    risk_accepted=data.get('risk_accepted', False),
                    risk_accepted_by=data.get('risk_accepted_by'),
                    risk_acceptance_reason=data.get('risk_acceptance_reason'),
                    retest_date=data.get('retest_date'),
                )

                self.vulnerabilities[vuln.vuln_id] = vuln

            except Exception as e:
                self.logger.error(f"Failed to load vulnerability {vuln_file}: {e}")


class VulnerabilityManagementSystem:
    """
    Complete vulnerability management system.

    Integrates scanning, tracking, and remediation.
    """

    def __init__(self, vuln_dir: Path = Path('vulnerabilities')):
        """
        Initialize vulnerability management system.

        Args:
            vuln_dir: Directory for vulnerability records
        """
        self.scanner = VulnerabilityScanner()
        self.manager = VulnerabilityManager(vuln_dir)
        self.logger = logging.getLogger(__name__)

    async def run_full_scan(self) -> Dict[str, List[Vulnerability]]:
        """
        Run full vulnerability scan across all components.

        Returns:
            Dictionary of vulnerabilities by scanner
        """
        results = {}

        self.logger.info("Starting full vulnerability scan...")

        # Scan Python dependencies
        self.logger.info("Scanning Python dependencies...")
        results['python_pip_audit'] = await self.scanner.scan_python_dependencies()
        results['python_safety'] = await self.scanner.scan_with_safety()

        # Scan OS packages
        self.logger.info("Scanning OS packages...")
        results['os_packages'] = await self.scanner.scan_os_packages()

        # Add all vulnerabilities to manager
        total_new = 0
        for scanner_name, vulns in results.items():
            for vuln in vulns:
                if self.manager.add_vulnerability(vuln):
                    total_new += 1

        self.logger.info(f"Vulnerability scan complete. Found {total_new} new vulnerabilities.")

        return results

    def get_summary(self) -> Dict[str, Any]:
        """Get vulnerability summary."""
        return self.manager.get_vulnerability_summary()

    def get_prioritized_list(self) -> List[Vulnerability]:
        """Get prioritized vulnerability list."""
        return self.manager.prioritize_vulnerabilities()


# Global instance
_vulnerability_system: Optional[VulnerabilityManagementSystem] = None


def get_vulnerability_system(
    vuln_dir: Optional[Path] = None
) -> VulnerabilityManagementSystem:
    """
    Get global vulnerability management system instance.

    Args:
        vuln_dir: Vulnerability directory (required on first call)

    Returns:
        VulnerabilityManagementSystem instance
    """
    global _vulnerability_system
    if _vulnerability_system is None:
        if vuln_dir is None:
            vuln_dir = Path('vulnerabilities')

        _vulnerability_system = VulnerabilityManagementSystem(vuln_dir)

    return _vulnerability_system
